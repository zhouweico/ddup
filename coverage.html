
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>errors: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">ddup-apis/internal/errors/errors.go (100.0%)</option>
				
				<option value="file1">ddup-apis/internal/logger/logger.go (80.0%)</option>
				
				<option value="file2">ddup-apis/internal/model/user.go (0.0%)</option>
				
				<option value="file3">ddup-apis/internal/model/user_session.go (0.0%)</option>
				
				<option value="file4">ddup-apis/internal/repository/repository.go (0.0%)</option>
				
				<option value="file5">ddup-apis/internal/repository/user_session.go (0.0%)</option>
				
				<option value="file6">ddup-apis/internal/service/user.go (0.0%)</option>
				
				<option value="file7">ddup-apis/internal/utils/convert.go (0.0%)</option>
				
				<option value="file8">ddup-apis/internal/utils/jwt.go (0.0%)</option>
				
				<option value="file9">ddup-apis/internal/utils/password.go (87.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package errors

import (
        "fmt"
        "net/http"
)

// AppError 自定义错误类型
type AppError struct {
        Code    int    // HTTP 状态码
        Message string // 错误信息
        Err     error  // 原始错误
}

func (e *AppError) Error() string <span class="cov8" title="1">{
        if e.Err != nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s: %v", e.Message, e.Err)
        }</span>
        <span class="cov8" title="1">return e.Message</span>
}

// 预定义错误
var (
        ErrInvalidRequest = &amp;AppError{
                Code:    http.StatusBadRequest,
                Message: "无效的请求参数",
        }

        ErrUnauthorized = &amp;AppError{
                Code:    http.StatusUnauthorized,
                Message: "未授权访问",
        }

        ErrForbidden = &amp;AppError{
                Code:    http.StatusForbidden,
                Message: "禁止访问",
        }

        ErrNotFound = &amp;AppError{
                Code:    http.StatusNotFound,
                Message: "资源不存在",
        }

        ErrInternalServer = &amp;AppError{
                Code:    http.StatusInternalServerError,
                Message: "服务器内部错误",
        }
)

// New 创建新的应用错误
func New(code int, message string, err error) *AppError <span class="cov8" title="1">{
        return &amp;AppError{
                Code:    code,
                Message: message,
                Err:     err,
        }
}</span>

// Wrap 包装已有错误
func Wrap(err error, message string) *AppError <span class="cov8" title="1">{
        if appErr, ok := err.(*AppError); ok </span><span class="cov8" title="1">{
                return appErr
        }</span>
        <span class="cov8" title="1">return &amp;AppError{
                Code:    http.StatusInternalServerError,
                Message: message,
                Err:     err,
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package logger

import (
        "os"

        "ddup-apis/internal/config"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "gopkg.in/natefinch/lumberjack.v2"
)

var Log *zap.Logger

func InitLogger(cfg *config.Config) error <span class="cov8" title="1">{
        // 设置日志输出格式
        encoderConfig := zapcore.EncoderConfig{
                TimeKey:        "time",
                LevelKey:       "level",
                NameKey:        "logger",
                CallerKey:      "caller",
                MessageKey:     "msg",
                StacktraceKey:  "stacktrace",
                LineEnding:     zapcore.DefaultLineEnding,
                EncodeLevel:    zapcore.CapitalLevelEncoder,
                EncodeTime:     zapcore.ISO8601TimeEncoder,
                EncodeDuration: zapcore.SecondsDurationEncoder,
                EncodeCaller:   zapcore.ShortCallerEncoder,
        }

        // 设置日志轮转
        writer := &amp;lumberjack.Logger{
                Filename:   cfg.Log.Filename,
                MaxSize:    cfg.Log.MaxSize,    // 每个日志文件最大尺寸（MB）
                MaxBackups: cfg.Log.MaxBackups, // 保留旧文件的最大个数
                MaxAge:     cfg.Log.MaxAge,     // 保留旧文件的最大天数
                Compress:   cfg.Log.Compress,   // 是否压缩
        }

        // 同时输出到控制台和文件
        core := zapcore.NewTee(
                zapcore.NewCore(
                        zapcore.NewJSONEncoder(encoderConfig),
                        zapcore.AddSync(writer),
                        cfg.Log.Level,
                ),
                zapcore.NewCore(
                        zapcore.NewConsoleEncoder(encoderConfig),
                        zapcore.AddSync(os.Stdout),
                        cfg.Log.Level,
                ),
        )

        // 创建 logger
        Log = zap.New(core, zap.AddCaller(), zap.AddCallerSkip(1))

        return nil
}</span>

// 提供便捷的日志方法
func Info(msg string, fields ...zap.Field) <span class="cov8" title="1">{
        Log.Info(msg, fields...)
}</span>

func Error(msg string, fields ...zap.Field) <span class="cov8" title="1">{
        Log.Error(msg, fields...)
}</span>

func Debug(msg string, fields ...zap.Field) <span class="cov8" title="1">{
        Log.Debug(msg, fields...)
}</span>

func Warn(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        Log.Warn(msg, fields...)
}</span>

func Fatal(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        Log.Fatal(msg, fields...)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package model

import (
        "time"

        "gorm.io/gorm"
)

type User struct {
        Username      string     `gorm:"type:varchar(32);uniqueIndex;not null" json:"username"`
        Password      string     `gorm:"size:100;not null" json:"-"`
        Email         string     `gorm:"size:100;null" json:"email"`
        Mobile        string     `gorm:"size:20;null" json:"mobile"`
        Location      string     `gorm:"size:100;null" json:"location"`
        Nickname      string     `gorm:"size:50" json:"nickname"`
        Bio           string     `gorm:"size:500" json:"bio"`
        Gender        string     `gorm:"size:10;default:'unknown'" json:"gender"`
        Birthday      *time.Time `json:"birthday"`
        Avatar        string     `gorm:"size:255" json:"avatar"`
        Status        int        `gorm:"default:1;not null" json:"status"`
        LastLogin     *time.Time `json:"last_login"`
        LoginAttempts int        `gorm:"default:0" json:"-"`
        LockedUntil   *time.Time `json:"-"`
        gorm.Model
}

// TableName 指定表名
func (User) TableName() string <span class="cov0" title="0">{
        return "users"
}</span>

// BeforeCreate 创建前的钩子
func (u *User) BeforeCreate(tx *gorm.DB) error <span class="cov0" title="0">{
        if u.Nickname == "" </span><span class="cov0" title="0">{
                u.Nickname = u.Username
        }</span>
        <span class="cov0" title="0">if u.Gender == "" </span><span class="cov0" title="0">{
                u.Gender = "unknown"
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package model

import (
        "time"

        "gorm.io/gorm"
)

type UserSession struct {
        UserID    uint      `gorm:"not null;index"`
        Token     string    `gorm:"type:varchar(255);not null;uniqueIndex"`
        IsValid   bool      `gorm:"not null;default:true"`
        ExpiredAt time.Time `gorm:"not null"`
        gorm.Model
}

func (UserSession) TableName() string <span class="cov0" title="0">{
        return "user_sessions"
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package repository

import "database/sql"

type Repository struct {
        db *sql.DB
}

func NewRepository(db *sql.DB) *Repository <span class="cov0" title="0">{
        return &amp;Repository{
                db: db,
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package repository

import (
        "context"
        "ddup-apis/internal/model"
)

func (r *Repository) CreateUserSession(ctx context.Context, session *model.UserSession) error <span class="cov0" title="0">{
        query := `
                INSERT INTO user_sessions (user_id, token, is_valid, expired_at)
                VALUES ($1, $2, $3, $4)
        `
        _, err := r.db.ExecContext(ctx, query,
                session.UserID, session.Token, session.IsValid, session.ExpiredAt)
        return err
}</span>

func (r *Repository) GetUserSessionByToken(ctx context.Context, token string) (*model.UserSession, error) <span class="cov0" title="0">{
        var session model.UserSession
        query := `SELECT user_id, token, is_valid, expired_at FROM user_sessions WHERE token = $1`
        err := r.db.QueryRowContext(ctx, query, token).Scan(
                &amp;session.UserID, &amp;session.Token, &amp;session.IsValid, &amp;session.ExpiredAt,
        )
        return &amp;session, err
}</span>

func (r *Repository) InvalidateUserSession(ctx context.Context, token string) error <span class="cov0" title="0">{
        query := `UPDATE user_sessions SET is_valid = false WHERE token = $1`
        _, err := r.db.ExecContext(ctx, query, token)
        return err
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package service

import (
        "context"
        "ddup-apis/internal/logger"
        "ddup-apis/internal/model"
        "ddup-apis/internal/utils"
        "fmt"
        "time"

        "ddup-apis/internal/errors"

        "go.uber.org/zap"
        "gorm.io/gorm"
)

type IUserService interface {
        Register(ctx context.Context, username, password string) error
        Login(ctx context.Context, username, password string) (*LoginResult, error)
        ValidateToken(token string) (*TokenValidationResult, error)
        Logout(ctx context.Context, token string) error
        GetUserByID(ctx context.Context, userID uint) (*model.User, error)
        ChangePassword(ctx context.Context, userID uint, oldPassword, newPassword string) error
        UpdateUser(ctx context.Context, userID uint, updates map[string]interface{}) error
        DeleteUser(ctx context.Context, userID uint) error
}

type LoginResult struct {
        Token     string
        CreatedAt time.Time
        ExpiresIn int64
        ExpiredAt time.Time
        User      *model.User
}

type TokenValidationResult struct {
        UserID   uint
        Username string
        IsValid  bool
}

type UserService struct {
        db *gorm.DB
}

func NewUserService(db *gorm.DB) *UserService <span class="cov0" title="0">{
        return &amp;UserService{db: db}
}</span>

func (s *UserService) Register(ctx context.Context, username, password string) error <span class="cov0" title="0">{
        var existingUser model.User
        result := s.db.Where("username = ?", username).First(&amp;existingUser)

        if result.Error == nil </span><span class="cov0" title="0">{
                return errors.New(400, "用户名已存在", nil)
        }</span>

        <span class="cov0" title="0">if result.Error != gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                return fmt.Errorf("查询用户失败: %w", result.Error)
        }</span>

        <span class="cov0" title="0">hashedPassword, err := utils.HashPassword(password)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("密码加密失败", zap.Error(err))
                return fmt.Errorf("密码加密失败: %w", err)
        }</span>

        <span class="cov0" title="0">newUser := model.User{
                Username: username,
                Password: hashedPassword,
        }

        if err := s.db.Create(&amp;newUser).Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("创建用户失败", zap.Error(err))
                return fmt.Errorf("创建用户失败: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *UserService) Login(ctx context.Context, username, password string) (*LoginResult, error) <span class="cov0" title="0">{
        var user model.User
        if err := s.db.Where("username = ?", username).First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, errors.New(404, "用户不存在", nil)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">if !utils.ComparePasswords(user.Password, password) </span><span class="cov0" title="0">{
                return nil, errors.New(401, "密码错误", nil)
        }</span>

        <span class="cov0" title="0">token, createdAt, expiresIn, expiredAt, err := utils.GenerateToken(user.ID, user.Username)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("生成令牌失败", zap.Error(err))
                return nil, fmt.Errorf("生成令牌失败: %w", err)
        }</span>

        <span class="cov0" title="0">s.db.Model(&amp;user).Update("last_login", time.Now())

        return &amp;LoginResult{
                Token:     token,
                User:      &amp;user,
                CreatedAt: createdAt,
                ExpiresIn: expiresIn,
                ExpiredAt: expiredAt,
        }, nil</span>
}

func (s *UserService) ValidateToken(token string) (*TokenValidationResult, error) <span class="cov0" title="0">{
        var session model.UserSession
        if err := s.db.Where("token = ?", token).First(&amp;session).Error; err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return &amp;TokenValidationResult{IsValid: false}, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("验证token失败: %w", err)</span>
        }

        <span class="cov0" title="0">if !session.IsValid || time.Now().After(session.ExpiredAt) </span><span class="cov0" title="0">{
                if err := s.db.Model(&amp;session).Update("is_valid", false).Error; err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("更新会话状态失败: %w", err)
                }</span>
                <span class="cov0" title="0">return &amp;TokenValidationResult{IsValid: false}, nil</span>
        }

        <span class="cov0" title="0">var user model.User
        if err := s.db.First(&amp;user, session.UserID).Error; err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(404, "获取用户信息失败", err)
        }</span>

        <span class="cov0" title="0">return &amp;TokenValidationResult{
                UserID:   user.ID,
                Username: user.Username,
                IsValid:  true,
        }, nil</span>
}

func (s *UserService) Logout(ctx context.Context, token string) error <span class="cov0" title="0">{
        return s.db.Model(&amp;model.UserSession{}).
                Where("token = ?", token).
                Update("is_valid", false).Error
}</span>

func (s *UserService) GetUserByID(ctx context.Context, userID uint) (*model.User, error) <span class="cov0" title="0">{
        var user model.User
        if err := s.db.First(&amp;user, userID).Error; err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, errors.New(404, "用户不存在", nil)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (s *UserService) UpdateUser(ctx context.Context, id uint, updates map[string]interface{}) error <span class="cov0" title="0">{
        delete(updates, "id")
        delete(updates, "password")
        delete(updates, "created_at")
        delete(updates, "deleted_at")

        result := s.db.Model(&amp;model.User{}).Where("id = ?", id).Updates(updates)
        if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.New(404, "用户不存在", nil)
        }</span>
        <span class="cov0" title="0">return result.Error</span>
}

func (s *UserService) DeleteUser(ctx context.Context, userID uint) error <span class="cov0" title="0">{
        result := s.db.Delete(&amp;model.User{}, userID)
        if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.New(404, "用户不存在", nil)
        }</span>
        <span class="cov0" title="0">return result.Error</span>
}

func (s *UserService) ChangePassword(ctx context.Context, userID uint, oldPassword, newPassword string) error <span class="cov0" title="0">{
        var user model.User
        if err := s.db.First(&amp;user, userID).Error; err != nil </span><span class="cov0" title="0">{
                return errors.New(404, "用户不存在", nil)
        }</span>

        <span class="cov0" title="0">if !utils.ComparePasswords(user.Password, oldPassword) </span><span class="cov0" title="0">{
                return errors.New(401, "原密码错误", nil)
        }</span>

        <span class="cov0" title="0">if oldPassword == newPassword </span><span class="cov0" title="0">{
                return errors.New(400, "新密码不能与原密码相同", nil)
        }</span>

        <span class="cov0" title="0">hashedPassword, err := utils.HashPassword(newPassword)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("密码加密失败: %w", err)
        }</span>

        <span class="cov0" title="0">return s.db.Model(&amp;user).Update("password", hashedPassword).Error</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package utils

import "strconv"

// StringToInt 将字符串转换为int，转换失败时返回0
func StringToInt(str string) int <span class="cov0" title="0">{
        val, err := strconv.Atoi(str)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return val</span>
}

// StringToUint 将字符串转换为uint，转换失败时返回0
func StringToUint(str string) uint <span class="cov0" title="0">{
        val, err := strconv.ParseUint(str, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return uint(val)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package utils

import (
        "errors"
        "time"

        "ddup-apis/internal/config"
        "ddup-apis/internal/db"
        "ddup-apis/internal/model"

        "github.com/golang-jwt/jwt/v5"
)

type Claims struct {
        UserID   uint   `json:"user_id"`
        Username string `json:"username"`
        jwt.RegisteredClaims
}

// GenerateToken 生成 JWT Token 并保存到数据库
func GenerateToken(userID uint, username string) (string, time.Time, int64, time.Time, error) <span class="cov0" title="0">{
        cfg := config.GetConfig()
        now := time.Now()
        expiresIn := int64(cfg.JWT.ExpiresIn.Seconds())
        expiredAt := now.Add(cfg.JWT.ExpiresIn)
        createdAt := now

        // 查找该用户所有有效的 Token
        var userSessions []model.UserSession
        err := db.DB.Where("user_id = ? AND is_valid = ? AND expired_at &gt; ?", userID, true, now).
                Order("created_at DESC").
                Find(&amp;userSessions).Error
        if err != nil </span><span class="cov0" title="0">{
                return "", time.Time{}, 0, time.Time{}, err
        }</span>

        <span class="cov0" title="0">if len(userSessions) &gt; 0 </span><span class="cov0" title="0">{
                // 保留最新的一个 Token，将其他的设置为无效
                latestSession := userSessions[0]
                if len(userSessions) &gt; 1 </span><span class="cov0" title="0">{
                        // 获取除最新 Token 外的所有 Token ID
                        var oldSessionIDs []int64
                        for i := 1; i &lt; len(userSessions); i++ </span><span class="cov0" title="0">{
                                oldSessionIDs = append(oldSessionIDs, int64(userSessions[i].ID))
                        }</span>

                        // 将旧 Token 标记为无效
                        <span class="cov0" title="0">if err = db.DB.Model(&amp;model.UserSession{}).
                                Where("id IN ?", oldSessionIDs).
                                Update("is_valid", false).Error; err != nil </span><span class="cov0" title="0">{
                                return "", time.Time{}, 0, time.Time{}, err
                        }</span>
                }

                // 延长最新 Token 的过期时间
                <span class="cov0" title="0">expiredAt = now.Add(cfg.JWT.ExpiresIn)
                latestSession.ExpiredAt = expiredAt
                latestSession.UpdatedAt = now

                if err = db.DB.Save(&amp;latestSession).Error; err != nil </span><span class="cov0" title="0">{
                        return "", time.Time{}, 0, time.Time{}, err
                }</span>

                <span class="cov0" title="0">return latestSession.Token, latestSession.CreatedAt, int64(cfg.JWT.ExpiresIn.Seconds()), expiredAt, nil</span>
        }

        // 将该用户所有旧 Token 标记为无效（包括已过期的）
        <span class="cov0" title="0">if err = db.DB.Model(&amp;model.UserSession{}).
                Where("user_id = ?", userID).
                Update("is_valid", false).Error; err != nil </span><span class="cov0" title="0">{
                return "", time.Time{}, 0, time.Time{}, err
        }</span>

        // 生成新的 Token
        <span class="cov0" title="0">expiredAt = createdAt.Add(cfg.JWT.ExpiresIn)
        expiresIn = int64(cfg.JWT.ExpiresIn.Seconds())

        claims := &amp;Claims{
                UserID:   userID,
                Username: username,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(expiredAt),
                        IssuedAt:  jwt.NewNumericDate(createdAt),
                },
        }

        jwtToken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        token, err := jwtToken.SignedString([]byte(cfg.JWT.Secret))
        if err != nil </span><span class="cov0" title="0">{
                return "", time.Time{}, 0, time.Time{}, err
        }</span>

        // 保存新 Token 到数据库
        <span class="cov0" title="0">newUserSession := model.UserSession{
                UserID:    userID,
                Token:     token,
                IsValid:   true,
                ExpiredAt: expiredAt,
        }

        if err = db.DB.Create(&amp;newUserSession).Error; err != nil </span><span class="cov0" title="0">{
                return "", time.Time{}, 0, time.Time{}, err
        }</span>

        <span class="cov0" title="0">return token, createdAt, expiresIn, expiredAt, nil</span>
}

// ParseToken 解析 JWT Token
func ParseToken(tokenString string) (*Claims, error) <span class="cov0" title="0">{
        cfg := config.GetConfig()
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return []byte(cfg.JWT.Secret), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(*Claims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                return claims, nil
        }</span>
        <span class="cov0" title="0">return nil, errors.New("invalid token")</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package utils

import (
        "errors"
        "fmt"

        "golang.org/x/crypto/bcrypt"
)

func ComparePasswords(hashedPassword string, plainPassword string) bool <span class="cov8" title="1">{
        err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(plainPassword))
        return err == nil
}</span>

func HashPassword(password string) (string, error) <span class="cov8" title="1">{
        if password == "" </span><span class="cov8" title="1">{
                return "", errors.New("密码不能为空")
        }</span>

        <span class="cov8" title="1">hashedBytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("生成密码哈希失败: %w", err)
        }</span>

        <span class="cov8" title="1">return string(hashedBytes), nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
